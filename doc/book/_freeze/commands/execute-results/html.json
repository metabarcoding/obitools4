{
  "hash": "44052e156ff134928de01c20aa868355",
  "result": {
    "markdown": "# The *OBITools V4* commands\n\n## Specifying the input files to *OBITools* commands\n\n## Options common to most of the *OBITools* commands\n\n### Specifying input format\n\nFive sequence formats are accepted for input files. *Fasta* (@sec-fasta) and *Fastq* (@sec-fastq) are the main ones, EMBL and Genbank allow the use of flat files produced by these two international databases. The last one, ecoPCR, is maintained for compatibility with previous *OBITools* and allows to read *ecoPCR* outputs as sequence files.\n\n-   `--ecopcr` : Read data following the *ecoPCR* output format.\n-   `--embl` Read data following the *EMBL* flatfile format.\n-   `--genbank` Read data following the *Genbank* flatfile format.\n\nSeveral encoding schemes have been proposed for quality scores in *Fastq* format. Currently, *OBITools* considers Sanger encoding as the standard. For reasons of compatibility with older datasets produced with *Solexa* sequencers, it is possible, by using the following option, to force the use of the corresponding quality encoding scheme when reading these older files.\n\n-   `--solexa` Decodes quality string according to the Solexa specification. (default: false)\n\n### Specifying output format\n\nOnly two output sequence formats are supported by OBITools, Fasta and Fastq. Fastq is used when output sequences are associated with quality information. Otherwise, Fasta is the default format. However, it is possible to force the output format by using one of the following two options. Forcing the use of Fasta results in the loss of quality information. Conversely, when the Fastq format is forced with sequences that have no quality data, dummy qualities set to 40 for each nucleotide are added.\n\n-   `--fasta-output` Read data following the ecoPCR output format.\n-   `--fastq-output` Read data following the EMBL flatfile format.\n\nOBITools allows multiple input files to be specified for a single command.\n\n-   `--no-order` When several input files are provided, indicates that there is no order among them. (default: false). \n                 Using such option can increase a lot the processing of the data.\n\n### The Fasta and Fastq annotations format\n\nOBITools extend the [Fasta](#the-fasta-sequence-format) and [Fastq](#the-fastq-sequence-format) formats by introducing a format for the title lines of these formats allowing to annotate every sequence. While the previous version of OBITools used an *ad-hoc* format for these annotation, this new version introduce the usage of the standard JSON format to store them.\n\nOn input, OBITools automatically recognize the format of the annotations, but two options allows to force the parsing following one of them. You should normally not need to use these options.\n\n-   `--input-OBI-header` FASTA/FASTQ title line annotations follow OBI format. (default: false)\n\n-   `--input-json-header` FASTA/FASTQ title line annotations follow json format. (default: false)\n\nOn output, by default annotation are formatted using the new JSON format. For compatibility with previous version of OBITools and with external scripts and software, it is possible to force the usage of the previous OBITools format.\n\n-   `--output-OBI-header|-O` output FASTA/FASTQ title line annotations follow OBI format. (default: false)\n\n-   `--output-json-header` output FASTA/FASTQ title line annotations follow json format. (default: false)\n\n#### System related options\n\n-   `--debug` (default: false)\n-   `--help\\|-h\\|-?` (default: false)\n-   `--max-cpu <int>` Number of parallele threads computing the result (default: 10)\n-   `--workers\\|-w <int>` Number of parallele threads computing the result (default: 9)\n\n## OBITools expression language\n\nSeveral OBITools (*e.g.* obigrep, obiannotate) allow the user to specify some simple expressions to compute values or define predicates. This expressions are parsed and evaluated using the [gval](https://pkg.go.dev/github.com/PaesslerAG/gval \"Gval (Go eVALuate) for evaluating arbitrary expressions Go-like expressions.\") go package, which allows for evaluating go-Like expression.\n\n### Variables usable in the expression\n\n- `sequence` is the sequence object on which the expression is evaluated.\n- `annotations`is a map object containing every annotations associated to the currently processed sequence.\n\n### Function defined in the language \n\n#### Instrospection functions {.unnumbered}\n\n- `len(x)`is a generic function allowing to retreive the size of a object. It returns \n  the length of a sequences, the number of element in a map like `annotations`, the number\n  of elements in an array. The reurned value is an `int`.\n\n#### Cast functions {.unnumbered}\n\n- `int(x)`  converts if possible the `x` value to an integer value. The function \n  returns an `int`.\n- `numeric(x)` converts if possible the `x` value to a float value. The function \n  returns a `float`.\n- `bool(x)` converts if possible the `x` value to a boolean value. The function \n  returns a `bool`.\n\n#### String related functions {.unnumbered}\n\n- `printf(format,...)` allows to combine several values to build a string. `format` follows the\n   classical C `printf` syntax. The function returns a `string`.\n- `subspc(x)` substitutes every space in the `x` string by the underscore (`_`) character. The function \n   returns a `string`. \n\n### Accessing to the sequence annotations\n\nThe `annotations` variable is a map object containing all the annotations associated to the currently processed sequence. Index of the map are the attribute names. It exists to possibillities to retreive\nan annotation. It is possible to use the classical `[]` indexing operator, putting the attribute name\nquoted by double quotes between them. \n\n```go\nannotations[\"direction\"]\n```\n\nThe above code retreives the `direction` annotation. A second notation using the dot (`.`) is often\nmore convenient.\n\n```go\nannotations.direction\n```\n\nSpecial attributes of the sequence are accessible only by dedicated methods of the `sequence` object.\n\n- The sequence identifier : `Id()`\n- THe sequence definition : `Definition()`\n\n\n## Metabarcode design and quality assessment\n\n### `obipcr`\n\n> Replace the `ecoPCR` original *OBITools*\n\n## File format conversions\n\n### `obiconvert`\n\n## Sequence annotations\n\n### `obiannotate` \n\n### `obitag` \n\n## Computations on sequences\n\n### `obipairing`\n\n> Replace the `illuminapairedends` original *OBITools*\n\n#### Alignment procedure {.unnumbered}\n\n`obipairing` is introducing a new alignment algorithm compared to the `illuminapairedend` command of the `OBITools V2`.\nNethertheless this new algorithm has been design to produce the same results than the previous, except in very few cases.\n\nThe new algorithm is a two-step procedure. First, a FASTN-type algorithm [@Lipman1985-hw] identifies the best offset between the two matched readings. This identifies the region of overlap. \n\nIn the second step, the matching regions of the two reads are extracted along with a flanking sequence of $\\Delta$ base pairs. The two subsequences are then aligned using a \"one side free end-gap\" dynamic programming algorithm. This latter step is only called if at least one mismatch is detected by the FASTP step. \n\nUnless the similarity between the two reads at their overlap region is very low, the addition of the flanking regions in the second step of the alignment ensures the same alignment as if the dynamic programming alignment was performed on the full reads. \n\n#### The scoring system {.unnumbered}\n\nIn the dynamic programming step, the match and mismatch scores take into account the quality scores of the two aligned nucleotides. By taking these into account, the probability of a true match can be calculated for each aligned base pair. \n\nIf we consider a nucleotide read with a quality score $Q$, the probability of misreading this base ($P_E$) is :\n$$\nP_E = 10^{-\\frac{Q}{10}}\n$$\n\nThus, when a given nucleotide $X$ is observed with the quality score $Q$. The probability that $X$ is really an $X$ is :\n\n$$\nP(X=X) = 1 - P_E\n$$\n\nOtherwise, $X$ is actually one of the three other possible nucleotides ($X_{E1}$, $X_{E2}$ or $X_{E3}$). If we suppose that the three reading error have the same probability :\n\n$$\nP(X=X_{E1}) = P(X=X_{E3}) = P(X=X_{E3}) = \\frac{P_E}{3}\n$$\n\nAt each position in an alignment where the two nucleotides $X_1$ and $X_2$ face each other (not a gapped position), the probability of a true match varies depending on whether $X_1=X_2$, an observed match, or $X_1 \\neq X_2$, an observed mismatch. \n\n**Probability of a true match when  $X_1=X_2$**\n\nThat probability can be divided in two parts. First $X_1$ and $X_2$ have been correctly read. The corresponding probability is :\n\n$$\n\\begin{aligned}\nP_{TM} &= (1- PE_1)(1-PE_2)\\\\ \n       &=(1 - 10^{-\\frac{Q_1}{10} } )(1 - 10^{-\\frac{Q_2}{10}} )\n\\end{aligned}\n$$\n\nSecondly, a match can occure if the true nucleotides read as $X_1$ and $X_2$ are not $X_1$ and $X_2$ but identical.\n\n$$\n\\begin{aligned}\nP(X_1==X_{E1}) \\cap P(X_2==X_{E1}) &= \\frac{P_{E1} P_{E2}}{9} \\\\\nP(X_1==X_{Ex}) \\cap P(X_2==X_{Ex}) & = \\frac{P_{E1} P_{E2}}{3}\n\\end{aligned}\n$$\n\nThe probability of a true match between $X_1$ and $X_2$ when $X_1 = X_2$ an observed match :\n\n$$\n\\begin{aligned}\nP(MATCH | X_1 = X_2) = (1- PE_1)(1-PE_2) + \\frac{P_{E1} P_{E2}}{3}\n\\end{aligned}\n$$\n\n**Probability of a true match when  $X_1 \\neq X_2$**\n\nThat probability can be divided in three parts. \n\na. $X_1$ has been correctly read and $X_2$ is a sequencing error and is actually equal to $X_1$. \n$$\nP_a =  (1-P_{E1})\\frac{P_{E2}}{3}\n$$\na. $X_2$ has been correctly read and $X_1$ is a sequencing error and is actually equal to $X_2$. \n$$\nP_b =  (1-P_{E2})\\frac{P_{E1}}{3}\n$$\na. $X_1$ and $X_2$ corresponds to sequencing error but are actually the same base $X_{Ex}$\n$$\nP_c = 2\\frac{P_{E1} P_{E2}}{9}\n$$\n\nConsequently : \n$$\n\\begin{aligned}\nP(MATCH | X_1 \\neq X_2) =  (1-P_{E1})\\frac{P_{E2}}{3} +  (1-P_{E2})\\frac{P_{E1}}{3} + 2\\frac{P_{E1} P_{E2}}{9}\n\\end{aligned}\n$$\n\n**Probability of a match under the random model**\n\nThe second considered model is a pure random model where every base is equiprobable, hence having a probability of occurrence of a nucleotide equals $0.25$. Under that hypothesis \n\n$$\nP(MATCH | \\text{Random model}) = 0.25\n$$\n\n**The score is a log ration of likelyhood**\n\nScore is define as the logarithm of the ratio between the likelyhood of the observations considering the sequencer error model over tha likelyhood u\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Evolution of the match and mismatch scores when the quality of base is 20 while the second range from 10 to 40.](commands_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n### `obimultiplex`\n\n> Replace the `ngsfilter` original *OBITools*\n\n### `obicomplement`\n\n### `obiclean`\n\n### `obiuniq`\n\n## Sequence sampling and filtering \n\n### `obigrep` \n\n## Utilities\n\n### `obicount`\n\n`obicount` counts the number of sequence records, the sum of the ``count`` attributes, and the sum\nof the length of all the sequences.\n\n*Example:*\n\n``` bash        \nobicount seq.fasta  \n```\nPrints the number of sequence records contained in the ``seq.fasta`` \nfile and the sum of their ``count`` attributes.\n\n*Options specific to the command*\n\n-  `--reads|-r `            Prints read counts. \n-   `--symbols|-s`           Prints symbol counts. \n-   `--variants|-v`          Prints variant counts. \n\n### `obidistribute`\n\n### `obifind`\n\n> Replace the `ecofind` original *OBITools.*\n\n",
    "supporting": [
      "commands_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}